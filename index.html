<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebXR AR Card Menu - Interactive 3D Cards</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 1;
    }
    #start-button {
      padding: 12px 24px;
      font-size: 18px;
      background: rgba(72, 118, 255, 0.8);
      color: white;
      border: none;
      border-radius: 30px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    #start-button:hover {
      background: rgba(72, 118, 255, 1);
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }
    #status {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 12px 20px;
      border-radius: 24px;
      font-size: 16px;
      font-weight: 500;
      margin: 0;
      backdrop-filter: blur(5px);
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      max-width: 80%;
      text-align: center;
      display: none;
      z-index: 1000;
    }
    .exit-ar {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.25);
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      cursor: pointer;
      backdrop-filter: blur(5px);
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      display: none;
    }
    .xr-active .exit-ar {
      display: flex;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <button id="start-button">Enter AR Card Menu</button>
  </div>
  
  <button class="exit-ar" id="exit-ar">Ã—</button>
  <div id="status"></div>
  
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';
    import { TextGeometry } from 'https://unpkg.com/three@0.150.1/examples/jsm/geometries/TextGeometry.js';
    import { FontLoader } from 'https://unpkg.com/three@0.150.1/examples/jsm/loaders/FontLoader.js';

    // Variables for XR
    let camera, scene, renderer;
    let controllers = [];
    let xrSession = null;
    let cards = [];
    let font;
    let raycaster;
    let hoveredCard = null;
    let cardData = [
      {
        title: "Nature Escape",
        description: "Immerse yourself in stunning landscapes and natural wonders from around the world.",
        color: 0x4ade80,
        position: new THREE.Vector3(-0.2, 0, -0.5)
      },
      {
        title: "3D Design Studio",
        description: "Create amazing 3D designs with powerful intuitive tools in augmented reality.",
        color: 0x60a5fa,
        position: new THREE.Vector3(0.2, 0, -0.5)
      },
      {
        title: "AR Games",
        description: "Experience next-generation gaming with our collection of AR-powered interactive games.",
        color: 0xf472b6,
        position: new THREE.Vector3(-0.2, -0.22, -0.5)
      },
      {
        title: "Virtual Gallery",
        description: "Explore curated art exhibitions and immersive installations in your own space.",
        color: 0xfbbf24,
        position: new THREE.Vector3(0.2, -0.22, -0.5)
      }
    ];

    // Initialize WebXR components
    function init() {
      // Scene setup
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      
      // Raycaster for interaction
      raycaster = new THREE.Raycaster();

      // Renderer setup
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 0);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      // Handle window resize
      window.addEventListener('resize', onWindowResize);

      // Set up event listeners
      document.getElementById('start-button').addEventListener('click', startARSession);
      document.getElementById('exit-ar').addEventListener('click', endARSession);
      
      // Load font for text
      const fontLoader = new FontLoader();
      fontLoader.load('https://unpkg.com/three@0.150.1/examples/fonts/helvetiker_regular.typeface.json', (loadedFont) => {
        font = loadedFont;
      });
    }

    // Start AR session
    function startARSession() {
      if (!navigator.xr) {
        updateStatus('WebXR is not supported in this browser.');
        return;
      }
      
      navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
        if (supported) {
          const sessionInit = { 
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay', 'hand-tracking'], 
            domOverlay: { root: document.body } 
          };
          
          navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
        } else {
          updateStatus('WebXR AR session is not supported on this device.');
        }
      });
    }

    // Handle AR session start
    function onSessionStarted(session) {
      xrSession = session;
      
      // Hide start button
      document.getElementById('start-button').style.display = 'none';
      
      // Set up XR scene
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);
      
      // Add XR active class to body
      document.body.classList.add('xr-active');
      
      // Set up controllers
      setupControllers(session);
      
      // Create card menu
      createCardMenu();
      
      // Start animation loop
      renderer.setAnimationLoop(render);
      
      // Handle session end
      session.addEventListener('end', onSessionEnd);
      
      updateStatus('Welcome to AR Card Menu! Point at cards to interact.');
    }
    
    // End AR session
    function endARSession() {
      if (xrSession) {
        xrSession.end();
      }
    }
    
    function onSessionEnd() {
      // Remove XR active class from body
      document.body.classList.remove('xr-active');
      
      // Show start button again
      document.getElementById('start-button').style.display = 'block';
      
      // Clear status
      document.getElementById('status').style.display = 'none';
      
      // Reset state
      cards = [];
      controllers = [];
      
      // Stop animation loop
      renderer.setAnimationLoop(null);
      xrSession = null;
      
      // Clear scene
      clearScene();
    }
    
    function clearScene() {
      // Remove all objects from scene
      while(scene.children.length > 0) { 
        const object = scene.children[0];
        if (object.geometry) object.geometry.dispose();
        if (object.material) object.material.dispose();
        scene.remove(object); 
      }
    }

    function setupControllers(session) {
      // Set up controllers
      for (let i = 0; i < 2; i++) {
        const controller = renderer.xr.getController(i);
        controller.userData.id = i;
        scene.add(controller);
        
        // Add visual ray indicator
        const rayGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -5)
        ]);
        
        const rayMaterial = new THREE.LineBasicMaterial({
          color: i === 0 ? 0x6699ff : 0xff6666,
          opacity: 0.7,
          transparent: true,
          linewidth: 2
        });
        
        const ray = new THREE.Line(rayGeometry, rayMaterial);
        ray.name = 'ray';
        ray.scale.z = 5;
        controller.add(ray);
        
        // Add controller mesh
        const handGeometry = new THREE.SphereGeometry(0.015, 16, 16);
        const handMaterial = new THREE.MeshStandardMaterial({
          color: i === 0 ? 0x6699ff : 0xff6666,
          roughness: 0.3,
          metalness: 0.5,
          transparent: true,
          opacity: 0.7
        });
        const handMesh = new THREE.Mesh(handGeometry, handMaterial);
        controller.add(handMesh);
        
        controllers.push(controller);
      }
    }
    
    function createCardMenu() {
      // Check if font is loaded
      if (!font) {
        // Try again in 100ms
        setTimeout(createCardMenu, 100);
        return;
      }
      
      // Calculate position in front of the user
      const cameraOffset = new THREE.Vector3(0, 0, -0.7);
      cameraOffset.applyQuaternion(camera.quaternion);
      const menuPosition = camera.position.clone().add(cameraOffset);
      
      // Create a group for the menu
      const menuGroup = new THREE.Group();
      menuGroup.position.copy(menuPosition);
      menuGroup.quaternion.copy(camera.quaternion);
      scene.add(menuGroup);
      
      // Create cards
      cardData.forEach((data, index) => {
        const card = createCard(data);
        card.userData = {
          index: index,
          title: data.title,
          description: data.description,
          originalPosition: card.position.clone(),
          originalScale: card.scale.clone(),
          originalRotation: card.rotation.clone(),
          baseColor: data.color,
          isHovered: false
        };
        menuGroup.add(card);
        cards.push(card);
      });
      
      updateStatus('Hover over cards to interact with them.');
    }
    
    function createCard(data) {
      // Create card group
      const cardGroup = new THREE.Group();
      cardGroup.position.copy(data.position);
      
      // Card dimensions
      const width = 0.18;
      const height = 0.12;
      const depth = 0.01;
      
      // Create card base with rounded corners
      const shape = new THREE.Shape();
      const radius = 0.02;
      
      shape.moveTo(-width/2 + radius, -height/2);
      shape.lineTo(width/2 - radius, -height/2);
      shape.quadraticCurveTo(width/2, -height/2, width/2, -height/2 + radius);
      shape.lineTo(width/2, height/2 - radius);
      shape.quadraticCurveTo(width/2, height/2, width/2 - radius, height/2);
      shape.lineTo(-width/2 + radius, height/2);
      shape.quadraticCurveTo(-width/2, height/2, -width/2, height/2 - radius);
      shape.lineTo(-width/2, -height/2 + radius);
      shape.quadraticCurveTo(-width/2, -height/2, -width/2 + radius, -height/2);
      
      const extrudeSettings = {
        steps: 1,
        depth: depth,
        bevelEnabled: true,
        bevelThickness: 0.005,
        bevelSize: 0.005,
        bevelSegments: 3
      };
      
      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      
      // Create gradient material
      const cardMaterial = new THREE.MeshPhysicalMaterial({
        color: data.color,
        metalness: 0.2,
        roughness: 0.3,
        reflectivity: 0.5,
        clearcoat: 0.8,
        clearcoatRoughness: 0.2,
        side: THREE.DoubleSide
      });
      
      const cardMesh = new THREE.Mesh(geometry, cardMaterial);
      cardMesh.castShadow = true;
      cardMesh.receiveShadow = true;
      cardGroup.add(cardMesh);
      
      // Add title text
      const titleGeometry = new TextGeometry(data.title, {
        font: font,
        size: 0.015,
        height: 0.002
      });
      
      titleGeometry.computeBoundingBox();
      const titleWidth = titleGeometry.boundingBox.max.x - titleGeometry.boundingBox.min.x;
      
      const titleMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const titleMesh = new THREE.Mesh(titleGeometry, titleMaterial);
      titleMesh.position.set(-titleWidth/2, 0.02, depth + 0.002);
      cardGroup.add(titleMesh);
      
      // Add description text
      const truncatedDesc = truncateText(data.description, 45);
      const descGeometry = new TextGeometry(truncatedDesc, {
        font: font,
        size: 0.008,
        height: 0.001
      });
      
      descGeometry.computeBoundingBox();
      const descWidth = descGeometry.boundingBox.max.x - descGeometry.boundingBox.min.x;
      
      const descMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const descMesh = new THREE.Mesh(descGeometry, descMaterial);
      descMesh.position.set(-descWidth/2, -0.02, depth + 0.002);
      cardGroup.add(descMesh);
      
      return cardGroup;
    }
    
    function truncateText(text, maxLength) {
      if (text.length <= maxLength) return text;
      return text.substring(0, maxLength - 3) + '...';
    }
    
    function updateCardHoverState(card, isHovered) {
      // Skip if state hasn't changed
      if (card.userData.isHovered === isHovered) return;
      
      // Update state
      card.userData.isHovered = isHovered;
      
      if (isHovered) {
        // Store previous hovered card if there was one
        if (hoveredCard && hoveredCard !== card) {
          updateCardHoverState(hoveredCard, false);
        }
        
        hoveredCard = card;
        
        // Animate to hovered state
        const targetScale = card.userData.originalScale.clone().multiplyScalar(1.2);
        const targetPosition = card.userData.originalPosition.clone().add(new THREE.Vector3(0, 0, 0.05));
        
        // Use TWEEN if available, or animate directly
        card.scale.copy(targetScale);
        card.position.copy(targetPosition);
        
        // Make card material more vibrant
        card.children.forEach(child => {
          if (child.material && child.material.color) {
            if (child.material.userData.originalColor === undefined) {
              child.material.userData.originalColor = child.material.color.clone();
            }
            
            if (child === card.children[0]) {
              // Main card body - enhance color
              child.material.emissive = new THREE.Color(card.userData.baseColor);
              child.material.emissiveIntensity = 0.3;
              child.material.clearcoat = 1.0;
            } else {
              // Text - make brighter
              child.material.emissive = new THREE.Color(0xffffff);
              child.material.emissiveIntensity = 0.5;
            }
          }
        });
        
        updateStatus(`${card.userData.title}: ${card.userData.description}`);
      } else {
        // Reset to original state
        card.scale.copy(card.userData.originalScale);
        card.position.copy(card.userData.originalPosition);
        card.rotation.copy(card.userData.originalRotation);
        
        // Reset material
        card.children.forEach(child => {
          if (child.material) {
            child.material.emissive = new THREE.Color(0x000000);
            child.material.emissiveIntensity = 0;
            
            if (child === card.children[0]) {
              child.material.clearcoat = 0.8;
            }
          }
        });
        
        if (hoveredCard === card) {
          hoveredCard = null;
          updateStatus('Hover over cards to interact with them.');
        }
      }
    }
    
    function updateDynamicRotation(card, controllerPosition) {
      if (!card.userData.isHovered) return;
      
      // Calculate angle between controller and card
      const cardWorldPos = new THREE.Vector3();
      card.getWorldPosition(cardWorldPos);
      
      const cardToController = new THREE.Vector3().subVectors(controllerPosition, cardWorldPos);
      cardToController.y = 0; // Ignore height difference for rotation
      cardToController.normalize();
      
      // Create subtle tilting effect based on controller position
      const tiltX = Math.max(-0.2, Math.min(0.2, -cardToController.z * 0.5));
      const tiltZ = Math.max(-0.2, Math.min(0.2, cardToController.x * 0.5));
      
      // Apply subtle rotation
      card.rotation.x = card.userData.originalRotation.x + tiltX;
      card.rotation.z = card.userData.originalRotation.z + tiltZ;
    }
    
    function render(timestamp, frame) {
      // Process controller interactions
      if (controllers.length > 0 && cards.length > 0) {
        controllers.forEach(controller => {
          if (!controller.visible) return;
          
          // Get controller position and direction
          const tempMatrix = new THREE.Matrix4();
          tempMatrix.identity().extractRotation(controller.matrixWorld);
          
          const raycasterOrigin = new THREE.Vector3();
          controller.getWorldPosition(raycasterOrigin);
          
          const raycasterDirection = new THREE.Vector3(0, 0, -1);
          raycasterDirection.applyMatrix4(tempMatrix);
          
          // Update raycaster
          raycaster.set(raycasterOrigin, raycasterDirection);
          
          // Check for intersections with cards
          const intersects = raycaster.intersectObjects(cards, true);
          
          if (intersects.length > 0) {
            // Find the parent card
            let parentCard = intersects[0].object;
            while (parentCard.parent && cards.indexOf(parentCard) === -1) {
              parentCard = parentCard.parent;
            }
            
            if (cards.includes(parentCard)) {
              // Update hover state
              updateCardHoverState(parentCard, true);
              
              // Update dynamic rotation
              updateDynamicRotation(parentCard, raycasterOrigin);
            }
          }
        });
      }
      
      // Animate cards
      cards.forEach((card, index) => {
        if (!card.userData.isHovered) {
          // Subtle floating animation for non-hovered cards
          card.position.y = card.userData.originalPosition.y + 
            Math.sin((timestamp / 1000) + index * 1.5) * 0.005;
        }
      });
      
      renderer.render(scene, camera);
    }
    
    function onWindowResize() {
      if (camera) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      }
      if (renderer) {
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    }
    
    function updateStatus(message) {
      const statusElement = document.getElementById('status');
      statusElement.textContent = message;
      statusElement.style.display = 'block';
      
      // Auto-hide after 5 seconds for non-error messages
      if (!message.includes('error') && !message.includes('not supported')) {
        setTimeout(() => {
          statusElement.style.display = 'none';
        }, 5000);
      }
    }
    
    // Initialize everything
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
